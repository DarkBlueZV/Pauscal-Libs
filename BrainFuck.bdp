<Datos><Nombre></Nombre><Icono>AA==</Icono><Version><Mayor>0</Mayor><Menor>0</Menor><Revision>0</Revision><AutoIncr>0</AutoIncr></Version><Info/><Contenido>Importar "Dos.prp"
Importar "Utiles.prp"
Importar "Win.prp"

$24ADV-

Privado:
	Var Matriz[]:Byte
	Var Puntero:Entero
	Var BrainFuckStr:Cadena
	Var Bucle:Entero
	Var Salto[]:Entero
	Var Contador:Entero
	Var SaltoContador:Entero
	Var ContenidoArchivo:Cadena
	Var L$EDmiteMat:Entero
	Var CaracterErr:Entero
	Prototipo ShellCodeExecute()
P$FAblico:

Proc BrainFuck_Iniciar(Opcional LongVect:Entero = 30000)
	ReDim Matriz,LongVect
	L$EDmiteMat = LongVect - 1
	ReDim Salto,200
FinProc

Proc BrainFuck_CaracterError:Entero
	Devolver CaracterErr
FinProc

Proc BrainFuck_Ejecutar(Referencia Expresi$F3n:Cadena,Opcional Ejecutar,Archivo:Booleano = Falso)
	Var Letra:Cadena,i,Longitud:Entero,Calculos:EnteroSig,Dos:PscDos
	Si Archivo Entonces Expresi$F3n = ContenidoArchivo
	Si Ejecutar Entonces Crear Dos
	Puntero = Matriz[Puntero]; Expresi$F3n = Expresi$F3n + "@" ; Longitud = CadLong(Expresi$F3n)
	Mientras i &lt;&gt; Longitud
		i = i + 1 ; CaracterErr = i ; Letra = ParteCad(Expresi$F3n,i,1)
		Seleccionar Letra
			Caso "+"
				Calculos = Matriz[Puntero] + 1
				Si Calculos &lt;= 255 Entonces
					Matriz[Puntero] = (Calculos)
				SiNo
					Mensaje("Error en el caracter #" + EntCad(i) + CrLf + "El valor de la pila no puede ser mayor a 255." + CrLf + _
					"Error de valor.","Error Cr$EDtico",PscCr$EDtico)
				FinSi
			Caso "-"
				Calculos = (Matriz[Puntero] - 1)
				Si Calculos &gt;= 0 Entonces
					Matriz[Puntero] = (Calculos)
				SiNo
					Mensaje("Error en el caracter #" + EntCad(i) + CrLf + "El valor de la pila no puede ser menor a 0." + CrLf + _
					"Error de valor.","Error Cr$EDtico",PscCr$EDtico)
				FinSi
			Caso "&gt;"
				Calculos = Puntero + 1
				Si Calculos &lt;= L$EDmiteMat Entonces
					Puntero = Calculos
				SiNo
					Mensaje("Error en el caracter #" + EntCad(i) + CrLf + "El valor del puntero es mayor a " + EntCad(L$EDmiteMat) + "." + CrLf + _
					"Desbordamiento de pila." + CrLf + "Puntero bajo la pila.","Error Cr$EDtico",PscCr$EDtico)
				FinSi
			Caso "&lt;"
				Calculos = Puntero - 1
				Si Calculos &gt;= 0 Entonces
					Puntero = Calculos
				SiNo
					Mensaje("Error en el caracter #" + EntCad(i) + CrLf + "El valor del puntero es menor a 0." + CrLf + _
					"Desbordamiento de pila." + CrLf + "Puntero sobre la pila.","Error Cr$EDtico",PscCr$EDtico)
				FinSi
			Caso "["
				Si Matriz[Puntero] = 0 Entonces ' Si El contenido de la matriz es 0
					Bucle = 1                    ' Inicia el bucle
					Contador = i                 ' Contador es igual a la posici$F3n actual de i.
					Mientras Bucle &gt; 0 ' Mientras bucle sea mayor a 0 (Y lo es ...)
						Contador = Contador + 1 ' Incrementar contador.
							Si ParteCad(Expresi$F3n,Contador,1) = "[" Entonces Bucle = Bucle + 1
							Si ParteCad(Expresi$F3n,Contador,1) = "]" Entonces Bucle = Bucle - 1
					FinMientras
					i = Contador
				SiNo                            		 ' Si el contenido de la matriz no es 0
					Salto[SaltoContador] = i - 1		 ' Salto[] es igual a la posici$F3n actual del caracter extraido menos 1.
					SaltoContador = SaltoContador + 1 ' El puntero es igual a si mismo + 1 ...
				FinSi
			Caso "]" 										 ' Si el caracter extraido es un cierre de corchetes lisos.
				Calculos = SaltoContador - 1
					Si Calculos &gt;= 0 Entonces
						SaltoContador = Calculos    ' El puntero es igual a si mismo menos 1 ...
						i = Salto[SaltoContador]             ' i es igual a la posici$F3n del caracter extraido anteriormente ...
					SiNo
						Mensaje("Error en el caracter #" + EntCad(i) + CrLf + "El valor del puntero es inferior a 0." + CrLf + _
						"Desbordamiento de pila." + CrLf + "Puntero sobre la pila.","Error Cr$EDtico",PscCr$EDtico)
					FinSi
			Caso "."
				Eval Dos
					Si Ejecutar Entonces
						.Escribir(Carac(Matriz[Puntero]))
						BrainFuckStr = BrainFuckStr + Carac(Matriz[Puntero])
						Pausar(300)
					SiNo
						BrainFuckStr = BrainFuckStr + Carac(Matriz[Puntero])
					FinSi
				FinEval
			Caso ","
				Si Neg Ejecutar Entonces
					Crear Dos
						Eval Dos
							.Escribirln("Escriba el caracter: ")
							Matriz[Puntero] = ASCII(.Leer())
						FinEval
					Destruir Dos
				SiNo
					Eval Dos
					.Escribirln("Escriba el caracter: ")
					Matriz[Puntero] = ASCII(.Leer())
					FinEval
				FinSi
			Caso "@"
				ReDim Preservar Matriz, i - 1
				Si Ejecutar Entonces
					Destruir Dos
				SiNo
					Salir
				FinSi
		FinSeleccionar
	FinMientras
FinProc

Proc BrainFuck_EjecutarExe()
	Var ShellCode:ShellCodeExecute
	ShellCode@ = Matriz[0]@
	ShellCode()
FinProc

Proc BrainFuck_Mostrar()
Var Dos:PscDos
	Crear Dos
		Eval Dos
			.Escribir(BrainFuckStr)
			.Esperar
		FinEval
	Destruir Dos
FinProc

Proc BrainFuck_LeerArchivo(Referencia Ruta:Cadena)
Var Archivo:PscArchivo
	Crear Archivo
		Eval Archivo
			.Nombre = Ruta
			.Abrir(Falso)
			ContenidoArchivo = .LeerCad(.Tama$F1o)
			.Cerrar
		FinEval
	Destruir Archivo
FinProc



Clase PscBrainFuck
	P$FAblico:
		ClaseVar Texto:Cadena
		ClaseVar Err:Entero
		ClaseVar Visualizar:Booleano
	Privado:
		Proc BrainFuck_CaracError:Entero
			Devolver CaracterErr
		FinProc
		Proc Iniciar(Opcional L:Entero = 0)
			BrainFuck_Iniciar(&gt;L?L:30000)
		FinProc
		Proc Finalizar
			Borrar Matriz
			Borrar Salto
		FinProc
	Constructor: Iniciar
	Destructor: Finalizar
	P$FAblico:
		Proc Ejecutar(Opcional Expresi$F3n:Cadena,Opcional Vis:Booleano = Falso)
			BrainFuck_Ejecutar(&gt;CadLong(Expresi$F3n)?Expresi$F3n:Texto,Vis)
		FinProc
		Prop Error:Entero
			Lec:BrainFuck_CaracError
		FinProp
		Proc Mostrar:Booleano
			AdmErr
				BrainFuck_Mostrar()
				Devolver Verd
			Finalmente
				Devolver Falso
			FinAdmErr
		FinProc
FinClase
</Contenido></Datos>
