<Datos><Nombre></Nombre><Icono>AA==</Icono><Version><Mayor>0</Mayor><Menor>0</Menor><Revision>0</Revision><AutoIncr>0</AutoIncr></Version><Info/><Contenido>Importar "Apis.prp"
Importar "Constantes.prp"
Importar "Memoria.prp"

$24ADV-
$24EBC-
$24CED-

' 26/03/2015
' Reemplazado CopyMemory por MemoriaCopiar.
' Curiosamente es la misma API, pero anda mas rapido.

' Por cada funci$F3n optimizada de esta libreria, se optimizan todos los procedimientos que
' Utilicen estas funciones, en velocidad y estabilidad.

' $E1 $E9 $ED $F3 $FA $F1 

' &lt; &gt;

' &amp;

' $24

Privado:
	Uni$F3n StrAndIntToArrayByte,Str:Cadena,Bite[]:Byte
	' Decid$ED usar una uni$F3n debido al costo de memoria de los procedimientos individuales.
	' Nota: Funciona excelentemente.
P$FAblico:

'By Yuki!
Proc RepCarac(Crc:Byte,Longitud:Entero):Cadena
	Si Longitud = 0 Entonces Salir
	Resultado = Espacio(Longitud)
	FillMemory(CadPtr(Resultado),Longitud,Crc)
FinProc

'By Paul Guerra
Proc CadLong(Referencia lpStr:Cadena):Entero
  Var @Ptr,Ret:Entero
  Si lpStr = "" Entonces Salir
  Ret=CadPtr(lpStr)
  Si (Ret=0) Salir
  Ptr@=Ret-4
  Devolver Ptr
FinProc

Proc CompararCad(Referencia Cad1,Cad2:Cadena,Opcional Sensitivo:Booleano):Booleano
	Si (Cad1 = "") Entonces GenerarError 0,"[CompararCad] primer parametro es vacio."
	Si (Cad2 = "") Entonces GenerarError 1,"[CompararCad] segundo parametro es vacio."
	Devolver &gt;(Sensitivo)?(lstrcmpi(Cad1,Cad2)):(lstrcmp(Cad1,Cad2))
FinProc

' Este es el anterior, parece ser que el metodo de arriba es mas eficiente con la velocidad,
' Pero como alarg$E1r la longitud de la cadena "invalidamente" podria generar errores graves.
Proc Espacio(Longitud:Entero):Cadena
   Var Ptr:StrAndIntToArrayByte
   Si Longitud &lt;= 0 Entonces GenerarError 0,"[Espacio] primer parametro es menor o igual a cero."
   ReDim Ptr.Bite,Longitud
   Devolver Ptr.Str
FinProc

'By Yuki!
'Este procedimiento es muy rapido, no es necesario reemplazar.
Proc Invertir(Referencia Expresi$F3n:Cadena):Cadena
	Var Matriz1[],Matriz2[]:Byte,l,i,e:Entero
	Si Expresi$F3n = "" Entonces GenerarError 0,"[Invertir] primer parametro es vacio."
	Matriz1 = MatrizByteDeCadena(Expresi$F3n)
	l = LongMat(Matriz1)
	e = l-1
	ReDim Matriz2,l
	Contar i = 0 a e
		Matriz2[i] = Matriz1[e]
		e = e - 1
	Seguir
	Devolver CadenaDeMatrizByte(Matriz2)
FinProc

' Carac ._.
Proc Carac(bByte:Byte):Cadena
  Var Temp:Cadena,@Ptr:Byte
  Temp="c"
  Ptr@=CadPtr(Temp)
  Ptr=bByte
  Devolver Temp
FinProc

' Ascii ._.
Proc Ascii(Referencia lpStr:Cadena):Byte
	Var i:Entero,@Ret:Byte
	Si lpStr = "" Entonces GenerarError 0,"[Ascii] primer parametro es vacio."
	Ret@=CadPtr(lpStr)
	Devolver Ret
FinProc

Proc IzquierdaCad(Referencia Texto:Cadena,Longit:EnteroSig):Cadena
	Si (CadLong(Texto)&lt;=Longit) Devolver Texto
	Devolver ParteCad(Texto,1,Longit)
FinProc ' $BF$BFSe producen errores al salir del procedimiento?? Dios santo ....................

' DerechaCad, Procedimiento mas rapido by Yuki.
' Jugando con punteros jajajaj
' Nota: Eh probado con otras alternativas, pero esta parece ser la mas veloz, mucho mas rapido que con CopyMemory.
' Nota2: Creo que esta usando "MoveMemory", me preocupa un poco el uso de estos punteros.
Proc DerechaCad(Referencia Str:Cadena,Pos1:Entero):Cadena
	Var Longi:Entero
	Si Str = "" Entonces GenerarError 0, "[DerechaCad] primer parametro es vacio."
	Longi = CadLong(Str)
	Si (Pos1 &gt; Longi) Entonces GenerarError 1, "[DerechaCad] segundo parametro es mayor a la longitud del primero."
	Si (Pos1 &lt;= 0) Entonces GenerarError 2, "[DerechaCad] segundo parametro es menor/igual a cero."
	Devolver ParteCad(Str,Pos1)
FinProc

Proc UnicodeACad(Referencia Expresi$F3n:Cadena):Cadena
	Si Expresi$F3n = "" Entonces GenerarError 0, "[UnicodeACad] primer parametro es vacio."
	Devolver Reemplazar(Expresi$F3n,Null,"")
FinProc

' CadAUnicode nuevo, Nativo &lt;
Proc CadAUnicode(Referencia Expresion:Cadena):Cadena
	Var Matriz1[],Matriz2[]:Byte,d,i,l:Entero
	Si Expresion = "" Entonces GenerarError 0, "[CadAUnicode] primer parametro es vacio."
	Matriz1 = MatrizByteDeCadena(Expresion)
	d = LongMat(Matriz1)
	ReDim Matriz2,(d*2)+1
	Repetir
		Matriz2[i] = Matriz1[l]
		l = l + 1
		i = i + 2
	HastaQue l = d
	Devolver CadenaDeMatrizByte(Matriz2)
FinProc

' ParteCad Optimizado By Yuki
Proc ParteCad(Referencia Texto:Cadena, Comienzo:EnteroSig, Opcional Longit:EnteroSig=-1):Cadena
	Var LenTxt:EnteroSig,@Ptr,@Ln:Entero
	Si Texto = "" Entonces GenerarError 0, "[ParteCad] primer parametro es vacio."
	LenTxt=CadLong(Texto)
	Si (Comienzo &gt; LenTxt) Entonces GenerarError 1, "[ParteCad] segundo parametro es mayor que la longitud del primero."
	Si (Comienzo &lt;= 0) Entonces GenerarError 2, "[ParteCad] segundo parametro es menor/igual a cero."
	Si (Longit &gt; LenTxt) Entonces GenerarError 3, "[ParteCad] tercer parametro es mayor a la longitud del primero."
	Longit = &gt;(Longit=-1) or (Longit + Comienzo &gt; LenTxt)?LenTxt-Comienzo+1:Longit
	Ptr@ = Resultado@
	Ln@ = Texto@
	Resultado = Espacio(Longit)
	Memoria_Copiar(Ptr,ln+Comienzo-1,Longit)
FinProc

' BuscarEnCad Alternativo by Yuki
' No son necesarias tantas sentencias, el procedimient parteCad ya hace el trabajo.
Proc BuscarEnCad(Referencia lpStr,lpMatch:Cadena,Opcional dwPos:Entero = 1):Entero
	Var i,l,r:Entero
	Si (lpStr = "") Entonces GenerarError 0, "[BuscarEnCad] primer parametro es vacio."
	r = CadLong(lpStr)
	Si (lpMatch = "") Entonces GenerarError 1, "[BuscarEnCad] segundo parametro es vacio."
	l = CadLong(lpMatch)
	Si l &gt; r Entonces Salir ' Devuelve cero ya que la cadena lpMatch por ser de mayor longitud es directamente inexistente.
	Si (dwPos &lt;= 0) Entonces GenerarError 2, "[BuscarEnCad] tercer parametro es menor/igual a cero."
	Si (dwPos &gt; r) Entonces GenerarError 3, "[BuscarEnCad] tercer parametro es mayor a la longitud del primer parametro."
	Contar i = dwPos a r
		Si ParteCad(lpStr,i,l) = lpMatch Entonces Devolver i
	Seguir
FinProc


Proc BuscarEnCadInv(Referencia lpStr,lpMatch:Cadena,Opcional dwPos:Entero):Entero
  Var i,LongMatch,TotLng:Entero
  Si lpStr = "" Entonces GenerarError 0, "[BuscarEnCadInv] primer parametro es vacio."
  Si lpMatch = 0 Entonces GenerarError 1, "[BuscarEnCadInv] segundo parametro es vacio."
  LongMatch=CadLong(lpMatch)
  TotLng=CadLong(lpStr)-LongMatch+1
  Si (dwPos&gt;TotLng) GenerarError 2, "[BuscarEnCadInv] tercer parametro es mayor a la longitud del primero."
  Si (dwPos=0) dwPos=TotLng
  Contar i = dwPos a 1 Dec
    Si (ParteCad(lpStr,i,LongMatch)=lpMatch) Devolver i
  Seguir
FinProc

Proc Reemplazar(Referencia Str,Match,Rep:Cadena, Opcional Pos:EnteroSig):Cadena
  Var i,LongMatch,CL,TotLng:Entero
  Si Str = "" GenerarError 0, "[Reemplazar] primer parametro es vacio."
  Si Match = "" Entonces GenerarError 1, "[Reemplazar] segundo parametro es vacio."
  'Si Rep = "" Entonces GenerarError 2, "[Reemplazar] tercer parametro es vacio."
  LongMatch=CadLong(Match)
  CL=CadLong(Str)
  TotLng=CL-LongMatch+1
  Si (Pos&gt;TotLng) GenerarError 3, "[Reemplazar] cuarto parametro es mayor a la longitud del primero - segundo + 1."
  Si (Pos=0) Pos=1
  Contar i = 1 a CL
    Si ((i&gt;=Pos) And (i&lt;=TotLng) And (ParteCad(Str,i,LongMatch)=Match))
      Resultado=Resultado+Rep
      i=i+LongMatch-1
    SiNo
      Resultado=Resultado+ParteCad(Str,i,1)
    FinSi
  Seguir
FinProc

'EntreCad Bu Yuki!
Proc EntreCad(Referencia Texto,Inicial,Final:Cadena,Opcional InicialB:Entero = 1):Cadena
	Var Str[]:Cadena
	Si (Texto = "") GenerarError 0, "[EntreCad] primer parametro es vacio."
	Si (Inicial = "") GenerarError 1, "[EntreCad] segundo parametro es vacio."
	Si (Final = "") GenerarError 2, "[EntreCad] tercer parametro es vacio."
	Si (InicialB &lt;= 0) GenerarError 3, "[EntreCad] cuarto parametro es menor o igual a cero."
	AdmErr
		Str = Separar(Texto,Inicial,InicialB)
		Str = Separar(Str[1],Final)
		Devolver Str[0]
	Controlar
		Salir
	FinAdmErr
FinProc

' MatrizByteDeCadena By Yuki.
Proc MatrizByteDeCadena(Referencia Temp:Cadena,Opcional Bool:Booleano):Byte[]
	Var Ptr:StrAndIntToArrayByte,i:Entero
	Si Temp = "" Entonces GenerarError 0, "[MatrizByteDeCadena] primer parametro es vacio."
	Si Bool
		i = CadLong(Temp)
		ReDim Resultado,i
		Memoria_Copiar(Resultado[0]@,CadPtr(Temp),i)
	SiNo
		Ptr.Str = Temp
		Resultado = Ptr.Bite
	FinSi
FinProc ' Genera Error al salir del procedimiento O.o
'Nota: Deja Vu O.o!!!11

Proc CadPtr(Referencia lpStr:Cadena):Entero
  Var @Dir:Entero
  Si lpStr = "" GenerarError 0, "[CadPtr] primer parametro es vacio."
  Dir@=lpStr@
  Devolver Dir
FinProc

Proc CadMayus(Referencia lpStr:Cadena):Cadena
	Si lpStr = "" GenerarError 0, "[CadMayus] primer parametro es vacio."
	Devolver CadDePtr(CharUpper(CadPtr(lpStr)))
FinProc

Proc CadMinus(Referencia lpStr:Cadena):Cadena
	Si lpStr = "" GenerarError 0, "[CadMinus] primer parametro es vacio."
	Devolver CadDePtr(CharLower(CadPtr(lpStr)))
FinProc

'CadenaDeMarizByte By Yuki
Proc CadenaDeMatrizByte(Referencia ByteAry[]:Byte):Cadena
  Var Ptr:StrAndIntToArrayByte
  Si LongMat(ByteAry) = 0 Entonces GenerarError 0, "[CadenaDeMatrizByte] primer parametro es vacio."
  Ptr.Bite = ByteAry
  Devolver Ptr.Str
FinProc

' CadenaDePtrCad By Paul Guerra - Modificado!
' Lo habia modificado utilizando matrices de bytes, pero como que CopyMemory es mas lento de esa forma, asique Ptr de cadenas nomas.
Proc CadDePtr(PtrCad:Entero):Cadena
  Var Temp[]:Byte, LenTxt:EnteroSig
  Si PtrCad &lt;= 0 Entonces GenerarError 0, "[CadDePtr] primer parametro es menor o igual cero."
  LenTxt=lstrlenptr(PtrCad)
  Si LenTxt&lt;1 GenerarError 1, "[CadDePtr] la longitud del buffer obtenido es menor a uno."
  Resultado = Espacio(LenTxt)
  Memoria_Copiar(CadPtr(Resultado),PtrCad,LenTxt)
FinProc

Proc TruncarCadena(Referencia lpStr:Cadena):Cadena 
  Var Pos:Entero
  Si lpStr = "" Entonces GenerarError 0, "[TruncarCadena] primer parametro es vacio."
  Pos=BuscarEnCad(lpStr,Null)
  Si (Pos=0) Devolver lpStr
  Si (Pos=1) Salir
  Devolver IzquierdaCad(lpStr,Pos-1)
FinProc

Proc Separar(Referencia Texto,Sep:Cadena, Opcional PosInicio:Entero=1, Opcional MaxRet:Entero):Cadena[]
  Var Pos,Ret,Mx,SepLen,TxtLen:Entero
  Si (Texto = "") Entonces GenerarError 0, "[Separar] primer parametro es vacio."
  Si (Sep = "") Entonces GenerarError 1, "[Separar] segundo parametro es vacio."
  Si (PosInicio &lt;= 0) Entonces GenerarError 2, "[Separar] tercer parametro es menor o igual a cero."
  Si (MaxRet &lt; 0) Entonces GenerarError 3, "[Separar] cuarto parametro es menor a cero."
  SepLen = CadLong(Sep)
  TxtLen = CadLong(Texto)
  Borrar Resultado
  Repetir
    Ret = BuscarEnCad(Texto,Sep,Pos+1) ' Ret = la posici$F3n del separador el separador
    Si (Ret=0) Salir Repetir ' Si no se encuentra el separador, salir.
    Redim Preservar Resultado, Mx + 1 ' Redimenciona el resultado.
    Resultado[Mx] = ParteCad(Texto,Pos+1,Ret-Pos-1) ' Resultado.Contador =
    Pos = Ret + SepLen - 1
    Mx = Mx + 1
    Si (MaxRet) Si (Mx = MaxRet) Salir Repetir
    Si (Pos&gt;=TxtLen) Salir Repetir
  PorSiempre
  ReDim Preservar Resultado, Mx + 1
  Resultado[Mx] = &gt; (Pos&gt;=TxtLen) ? ("") : (ParteCad(Texto,Pos+1))
FinProc

Proc CadObtPosMat(Referencia Ex,Del:Cadena):Entero[]
	Var A,B:Entero
	Repetir
		ReDim Preservar Resultado,B + 1
		A = BuscarEnCad(Ex,Del,A+1)
		Si A Entonces B = B + 1 ; SiNo ; ReDim Preservar Resultado,LongMat(Resultado) - 1 ; Salir
		Resultado[B - 1] = A
	PorSiempre
FinProc

Clase pscCadenas, _
  Buff[]:PSCCADENASINFO, _
  MaxBuff,iHwnd:Entero
P$FAblico:
  ClaseVar Eventos:PSCCADENAS_EVENTINFO
Privado:
  Proc evCambiar()
    Si (Eventos.AlCambiar@) Eventos.AlCambiar(hWnd,0)
  FinProc
  Proc evAdd(Pos:EnteroSig)
    Si (Eventos.AlAgregar@) Eventos.AlAgregar(hWnd,Pos)
  FinProc
  Proc evDel(Pos:EnteroSig)
    Si (Eventos.AlQuitar@) Eventos.AlQuitar(hWnd,Pos)
  FinProc
  Proc EsValido(Indice:Entero)
    Si (Indice&gt;=MaxBuff) GenerarError errParamInv
  FinProc
  Proc GetItem(Indice:Entero):Cadena
    EsValido(Indice)
    Resultado=Buff[Indice].Texto
  FinProc
  Proc SetItem(Valor:Cadena, Indice:Entero)
    EsValido(Indice)
    Buff[Indice].Texto=Valor
    evCambiar()
  FinProc
  Proc GetDato(Indice:Entero):EnteroSig
    EsValido(Indice)
    Resultado=Buff[Indice].Dato
  FinProc
  Proc SetDato(Valor:EnteroSig, Indice:Entero)
    EsValido(Indice)
    Buff[Indice].Dato=Valor
  FinProc
  Proc GetCantidad:Entero
    Resultado=MaxBuff
  FinProc
P$FAblico:
  Prop hWnd:Entero
    Lec:iHwnd
    Esc:iHwnd
  FinProp
  Prop Cantidad:Entero
    Lec:GetCantidad
  FinProp
  Prop Item:Cadena
    Lec:GetItem
    Esc:SetItem
  FinProp
  Prop Dato:EnteroSig
    Lec:GetDato
    Esc:SetDato
  FinProp
  Proc Agregar(Texto:Cadena)
    MaxBuff=MaxBuff+1
    Redim Preservar Buff,MaxBuff
    Buff[MaxBuff-1].Texto=Texto
    evAdd(MaxBuff-1)
  FinProc
  Proc Insertar(Texto:Cadena, Indice:Entero)
    Var i:Entero
    EsValido(Indice)
    Agregar("")
    Contar i=Indice+1 a MaxBuff
      Buff[i]=Buff[i-1]
    Seguir
    Buff[Indice].Texto=Texto
    evAdd(Indice)
  FinProc
  Proc Eliminar(Indice:Entero)
    Var i:Entero
    EsValido(Indice)
    MaxBuff=MaxBuff-1
    Contar i=Indice+1 a MaxBuff
      Buff[i-1]=Buff[i]
    Seguir
    Redim Preservar Buff,MaxBuff
    evDel(Indice)
  FinProc
FinClase
</Contenido></Datos>
