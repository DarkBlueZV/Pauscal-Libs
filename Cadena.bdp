Importar "Declare.prp"

$ADV-
$EBC-

Público:
Const CrLf        = #13#10
Const Null        = #0
Const Vacio       = #0
Const Defecto     = &0 ' Diseñado para establecer "Defecto" como parametro, Aprobechando el bug descubierto por PowerDeath.
Privado:
'Proc CallWindowProc(,,,,:Entero):Entero, "user32.dll" "CallWindowProcA" ' API
Proc VarCyFromR8(nro:Real, Referencia cy:Decimal):Entero, "oleaut32"
Público:

' #############################################################
' Nombre       : HexEnt
' Función      : Convierte una cadena hexadecimal a entero.
' Devolución   : Entero
' Autor        : Paul Guerra
' Parametros   : #1 {Cadena} Expresión a convertir.
' #############################################################
Proc HexEnt(hex:Cadena):Entero
   Var i:Byte
   Var car:Entero

   Contar i = CadLong(hex) a 1
      car = Ascii(ParteCad(hex, i))
      Si (i > 8) or (car < 48 and car > 58) or (car < 65 and car > 71) Entonces GenerarError errParamInv
      Resultado = Resultado + ((> car<65 ? car - 48 : car - 55) shr (i-1))
   Seguir
FinProc


' #############################################################
' Nombre       : EntHext
' Función      : Convierte una expresión a Hexadecimal.
' Devolución   : Cadena
' Autor        : Paul Guerra
' Parametros   : #1 {Entero} Valor a convertir[, #2 {Booleano} Rellenar con ceros.]
' #############################################################
Proc EntHex(lNum:Entero,Opcional FillWithZero:Booleano):Cadena
  Var Digit,i:Byte
  Contar i=1 a 8
    Si (lNum=0) And (FillWithZero=Falso) Salir
    Digit=lNum And &0F
    Resultado=Carac(>Digit<10?Digit+48:Digit+55)+Resultado
    lNum=lNum shr 4
  Seguir
FinProc

' EN DESARROLLO ###############################################
'Proc CadHex(Str:Cadena):Cadena
'Var i:Entero,Array[]:Byte
'Array = MatrizByteDeCadena(Str) ; Str = ""
'Contar i = 0 a Límite(Array)
'	Str = Str + EntCad(Array[i])
'Seguir
'Devolver Str
'FinProc

' EN DESARROLLO ###############################################
'Proc HexCad(Str:Cadena):Cadena
'Var i:Entero,Lt:Cadena
'Contar i = 1 a CadLong(Str)
'	Si Neg(EsPar(i)) Entonces Lt = Lt + Carac(CadEnt(ParteCad(Str,i,2)))
'Seguir 
'Devolver Lt
'FinProc

' #############################################################
' Nombre       : EsPar
' Función      : Verifica si un número es par.
' Devolución   : Booleano
' Autor        : PowerDeath
' Parametros   : #1 {Entero} Valor a comprobar.
' #############################################################
Proc EsPar(Número:Entero):Booleano
	Var Texto:Cadena
	Texto = EntCad(Número)
	Texto = DerechaCad(Texto,1)
	Seleccionar Texto
		Caso "2","4","6","8","0"
			Devolver Verd
		Caso Otro
			Devolver Falso
	FinSeleccionar
FinProc

' #############################################################
' Nombre       : RealDec2
' Función      : Convierte una expresión a decimal.
' Devolución   : Decimal
' Autor        : Paul Guerra
' Parametros   : #1 {Real} Valor a convertir.
' #############################################################
Proc RealDec2(nro:Real):Decimal
   VarCyFromR8(nro, Resultado)
FinProc

' #############################################################
' Nombre       : CadDec
' Función      : Convierte una expresión a decimal.
' Devolución   : Decimal
' Autor        : Paul Guerra
' Parametros   : #1 {Cadena} Valor a convertir.
' #############################################################
Proc CadDec(txt:Cadena):Decimal
   Resultado = RealDec2(CadReal(txt))
FinProc

' #############################################################
' Nombre       : DecCad
' Función      : Convierte una expresión a cadena.
' Devolución   : Cadena
' Autor        : Paul Guerra
' Parametros   : #1 {Decimal} Valor a convertir.
' #############################################################
Proc DecCad(nro:Decimal):Cadena
   Resultado = RealCad(DecReal(nro))
FinProc

' #############################################################
' Nombre       : EntDec
' Función      : Convierte una expresión a decimal.
' Devolución   : Decimal
' Autor        : Paul Guerra
' Parametros   : #1 {EnteroSig} Valor a convertir.
' #############################################################
Proc EntDec(nro:EnteroSig):Decimal
   Var @temp:EnteroSig
   temp@ = Resultado@
   temp = nro
   Resultado = Resultado * 10000
FinProc

' #############################################################
' Nombre       : DecEnt
' Función      : Convierte una expresión a entero con signo.
' Devolución   : EnteroSig
' Autor        : Paul Guerra
' Parametros   : #1 {Decimal} Valor a convertir.
' #############################################################
Proc DecEnt(nro:Decimal):EnteroSig
   Var @temp:Decimal
   Var da[]:EnteroSig
   da=[0,0]
   temp@ = da[0]@
   temp = nro/10000
   Resultado = da[0]
FinProc

' #############################################################
' Nombre       : EntreCad
' Función      : Obtiene la cadena entre dos cadenas establecidas.
' Devolución   : Cadena
' Autor        : PowerDeath
' Parametros   : #1 {Cadena} Texto completo, #2 {Cadena} Palabra inicial, #3 {Cadena} Palabra segundaria[, #4 {Entero} Posición inicial.]
' #############################################################
Proc EntreCad(Referencia Texto,Inicial,Final:Cadena,Opcional InicialB:Entero = 1):Cadena
	Var Str[]:Cadena
	Str = Separar(Texto,Inicial,InicialB)
	Str = Separar(Str[1],Final)
	Devolver Str[0]
FinProc

' #############################################################
' Nombre       : MatEliminar
' Función      : Elimina una expresión dentro de una matriz.
' Devolución   : Cadena[]
' Autor        : PowerDeath
' Parametros   : #1 {Cadena[]} Matriz completa, #2 {Cadena} Expresión a eliminar.
' #############################################################
Proc MatEliminar(Matriz[]:Cadena,Expresión:Cadena):Cadena[]
Var i:Entero,Matriz2[]:Cadena,Contador:Entero
ReDim Matriz2,1
Contar i = 0 a Límite(Matriz)
	Si Matriz[i] <> Expresión Entonces
		Si Contador = LongMat(Matriz2) Entonces ReDim Preservar Matriz2,LongMat(Matriz2) + 1
		Matriz2[Contador] = Matriz[i]
		Contador = Contador + 1
	FinSi
Seguir
	Resultado = Matriz2
FinProc

' #############################################################
' Nombre       : RepartirCad
' Función      : Reparte una cadena dentro de una matriz.
' Devolución   : Cadena[]
' Autor        : PowerDeath
' Parametros   : #1 {Cadena} Expresión a repartir, #2 {Entero} Cantidad a repartir.
' #############################################################
Proc RepartirCad(Textos:Cadena,Opcional LongitudCad:Entero = 1):Cadena[]
Var i,Longitud:Entero,Matriz[]:Cadena
Longitud = CadLong(Textos)
Si LongitudCad > Longitud Entonces GenerarError 0,"La longitud establecida es mayor a la longitud del texto."
Si EsPar(LongitudCad) Xor EsPar(Longitud) Entonces GenerarError 1, "Si la longitud del parametro #1 es par -" + CrLf + "El valor del segundo parametro tambien debe serlo."
ReDim Matriz, Longitud
i = 1
Mientras i <= Longitud
   Matriz[i - 1] = ParteCad(Textos,i,LongitudCad)
   i = i + LongitudCad
FinMientras
   Resultado = MatEliminar(Matriz,"")
FinProc

' #############################################################
' Nombre       : UnirCad
' Función      : Une una matriz de cadena.
' Devolución   : Cadena
' Autor        : PowerDeath
' Parametros   : #1 {Cadena[]} Matriz de cadena a unir.
' #############################################################
Proc UnirCad(Matriz[]:Cadena):Cadena
	Var Result:Cadena,i:Entero
	Contar i = 0 a Límite(Matriz)
		Result = Result + Matriz[i]
	Seguir
	Devolver Result
FinProc

' #############################################################
' Nombre       : RepartirEnt
' Función      : Reparte una expresión dentro de una matriz.
' Devolución   : Entero[]
' Autor        : PowerDeath
' Parametros   : #1 {Cadena} Expresión a repartir.
' #############################################################
Proc RepartirEnt(Números:Entero):Entero[]
Var i,Longitud,Matriz[]:Entero,Textos:Cadena
Textos = EntCad(Números)
Longitud = CadLong(Textos)
ReDim Matriz, Longitud
Contar i = 1 a Longitud
   Matriz[i -1] = CadEnt(ParteCad(Textos,i,1))
Seguir
   Resultado = Matriz
FinProc

' #############################################################
' Nombre       : UnirEnt
' Función      : Une o suma una matriz.
' Devolución   : Entero
' Autor        : PowerDeath
' Parametros   : #1 {Entero[]} Matriz[, #2 {Booleano} Sumar la matriz.]
' #############################################################
Proc UnirEnt(Matriz[]:Entero,Opcional Sumar:Booleano = Falso):Entero
	Var Result:Cadena,Beta:Entero,i:Entero
	Var Matris[]:Cadena
	'Matris = MatEntCad(Matriz)
	Contar i = 0 a Límite(Matriz)
		Si Sumar = Verd Entonces Beta = Beta + Matriz[i]
		Si Sumar = Falso Entonces Result = Result + EntCad(Matriz[i])
	Seguir
	Si Sumar = Verd Entonces Devolver Beta
	Si Sumar = Falso Entonces Devolver CadEnt(Result)
FinProc


Proc MatEntCad(Matriz[]:Entero):Cadena[]
	Var Result[]:Cadena,i:Entero
	Redim Result,LongMat(Matriz)
	Contar i = 0 a Límite(Matriz)
		Result[i] = EntCad(Matriz[i])
	Seguir
	Resultado = Result
FinProc


Proc MatCadEnt(Matriz[]:Cadena):Entero[]
	Var Result[],i:Entero
	Redim Result,LongMat(Matriz)
	Contar i = 0 a Límite(Matriz)
		Result[i] = CadEnt(Matriz[i])
	Seguir
	Resultado = Result
FinProc


Proc RepartirDec(Números:Decimal):Decimal[]
Var i,Longitud:Entero,Matriz[]:Decimal,Textos:Cadena
Textos = DecCad(Números)
Longitud = CadLong(Textos)
ReDim Matriz, Longitud
Contar i = 1 a Longitud
   Matriz[i -1] = CadDec(ParteCad(Textos,i,1))
Seguir
   Resultado = Matriz
FinProc


Proc RepartirReal(Números:Real):Real[]
Var i,Longitud:Entero,Matriz[]:Real,Textos:Cadena
Textos = RealCad(Números)
Longitud = CadLong(Textos)
ReDim Matriz, Longitud
Contar i = 1 a Longitud
   Matriz[i -1] = CadReal(ParteCad(Textos,i,1))
Seguir
   Resultado = Matriz
FinProc


Proc MatrizByteDeCadena(Referencia Temp:Cadena):Byte[]
Var i,lLen:Entero,bArr[]:Byte,Letra:Cadena
    lLen = CadLong(Temp)
    Redim bArr,lLen
    Contar i = 1 a lLen
      Letra = ParteCad(Temp,i, 1)
      bArr[i - 1] = Ascii(Letra)
    Seguir
    Resultado = bArr
FinProc


Proc EsSimbolo(Referencia PalabraA:Cadena):Booleano ' VERIFICAR
Var i:Entero
Var a:Cadena
Const nums = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
Resultado = Falso
Contar i = 1 a CadLong(PalabraA)
   a = ParteCad(PalabraA,i,1)
      Si Neg LetraExiste(Nums,a) > 0 Entonces
         Resultado = Verd
         Salir Contar
      FinSi
Seguir
FinProc


'Proc CadXor(Referencia Cadena1:Cadena):Cadena
'Var Kod,X2:Cadena
'Var X3:Entero
'Contar X3 = 1 a CadLong(Cadena1)
'X2 = ParteCad(Cadena1,X3,1)
'Kod = Kod + Carac(ASCII(X2) Xor 255)
'Seguir
'Devolver Kod
'FinProc


Proc Espacio(Longitud:Entero):Cadena
Devolver RepCarac(0,Longitud)
FinProc


Proc EsDecimal(Referencia PalabraA:Cadena):Booleano ' VERIFICAR
Var i:Entero
Var a,nums:Cadena
nums = "123456789."
Resultado = Verd
Contar i = 1 a CadLong(PalabraA)
   a = ParteCad(PalabraA,i,1)
      Si LetraExiste(Nums,a) = 0 Entonces
         Resultado = Falso
         Salir Contar
      FinSi
Seguir
FinProc


Proc EsAlfanumerico(Referencia PalabraA:Cadena):Booleano
Var i:Entero
Var nums,a:Cadena
nums = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
Resultado = Verd
Contar i = 1 a CadLong(PalabraA)
   a = ParteCad(PalabraA,i,1)
      Si LetraExiste(Nums,a) = 0 Entonces
         Resultado = Falso
         Salir Contar
      FinSi
Seguir
FinProc


Proc EsMinusculas(Referencia PalabraA:Cadena):Booleano
Var i:Entero
Var nums,a:Cadena
nums = "abcdefghijklmnopqrstuvwxyz"
Resultado = Verd
Contar i = 1 a CadLong(PalabraA)
   a = ParteCad(PalabraA,i,1)
      Si LetraExiste(Nums,a) = 0 Entonces
         Resultado = Falso
         Salir Contar
      FinSi
Seguir
FinProc


Proc EsMayusculas(Referencia PalabraA:Cadena):Booleano
Var i:Entero
Var nums,a:Cadena
nums = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
Resultado = Verd
Contar i = 1 a CadLong(PalabraA)
   a = ParteCad(PalabraA,i,1)
      Si LetraExiste(Nums,a) = 0 Entonces
         Resultado = Falso
         Salir Contar
      FinSi
Seguir
FinProc


Proc EsCadena(Referencia PalabraA:Cadena):Booleano
Var i:Entero
Var nums,a:Cadena
nums = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
Resultado = Verd
Contar i = 1 a CadLong(PalabraA)
   a = ParteCad(PalabraA,i,1)
      Si LetraExiste(Nums,a) = 0 Entonces
         Resultado = Falso
         Salir Contar
      FinSi
Seguir
FinProc


Proc EsNumero(Referencia NumeroA:Cadena):Booleano
Var i:Entero
Var nums,a:Cadena
nums = "0123456789"
Resultado = Verd
Contar i = 1 a CadLong(NumeroA)
   a = ParteCad(NumeroA,i,1)
      Si LetraExiste(Nums,a) = 0 Entonces
         Resultado = Falso
         Salir Contar
      FinSi
Seguir
FinProc


Proc LetraExiste(Referencia CadenaA,Caracter:Cadena):Booleano
Var Letra_A:Cadena,Longitud_A,Valor_A:Entero
Longitud_A = CadLong(CadenaA)
Resultado = Falso
Contar Valor_A = 1 a Longitud_A
   Letra_A = ParteCad(CadenaA,Valor_A,1)
   Si Letra_A = Caracter
      Resultado = Verd ; Salir Contar
   FinSi
Seguir
FinProc


Proc InvertirCad(Referencia Cadenilla:Cadena):Cadena
Var Longitudes,EsteNumero:Entero,TextoDevuelto,Letrita:Cadena
   Contar EsteNumero = CadLong(Cadenilla) a 1 Dec
      Letrita = ParteCad(Cadenilla,EsteNumero,1)
      TextoDevuelto = TextoDevuelto + Letrita
   Seguir
Devolver TextoDevuelto
FinProc


Proc InvertirEnt(Número:Entero):Entero
Var Longitudes,EsteNumero:Entero,TextoDevuelto,Letrita,Cadenilla:Cadena
Cadenilla = EntCad(Número)
   Contar EsteNumero = CadLong(Cadenilla) a 1 Dec
      Letrita = ParteCad(Cadenilla,EsteNumero,1)
      TextoDevuelto = TextoDevuelto + Letrita
   Seguir
Devolver CadEnt(TextoDevuelto)
FinProc


Proc CadPtr(Referencia lpStr:Cadena):Entero
  Var @Dir:Entero
  Dir@=lpStr@
  Resultado=Dir
FinProc


Proc CadLong(Referencia lpStr:Cadena):Entero
  Var @Ptr,Ret:Entero
  Ret=CadPtr(lpStr)
  Si (Ret=0) Salir
  Ptr@=Ret-4
  Resultado=Ptr
FinProc


Proc EntLong(Referencia lpStr:Entero):Entero
Var Matriz[]:Entero
Matriz = RepartirEnt(lpStr)
Devolver LongMat(Matriz)
FinProc


Proc CadMayus(Referencia lpStr:Cadena):Cadena
  CharUpperBuff(lpStr,CadLong(lpStr))
  Resultado=lpStr
FinProc


Proc CadMinus(Referencia lpStr:Cadena):Cadena
  CharLowerBuff(lpStr,CadLong(lpStr))
  Resultado=lpStr
FinProc


Proc Carac(Referencia bByte:Byte):Cadena
  Var Temp:Cadena, @Ptr:Byte
  Temp=" "
  Ptr@=CadPtr(Temp)
  Ptr=bByte
  Resultado=Temp
FinProc


Proc RepCarac(bByte:Byte,dwRep:Entero):Cadena
  Var Rep:Cadena, i:Entero
  Rep=Carac(bByte)
  Contar i = 1 a dwRep
    Resultado=Resultado + Rep
  Seguir
FinProc


Proc CadEnt(Referencia lpStr:Cadena):EnteroSig
  Var Temp:Cadena, LenCad:Entero, Num:EnteroSig
  LenCad=CadLong(lpStr)
  Temp=RepCarac(0,(LenCad+1)*2)
  MultiByteToWideChar(0,0,lpStr,LenCad,Temp,LenCad*2)
  Si (VarI4FromStr(Temp,0,0,Num)) GenerarError errTipoIncompatible
  Resultado=Num
FinProc


Proc EntCad(lNum:EnteroSig):Cadena
  Var Temp,Res:Cadena, LenCad:Entero
  $CED-
  VarBstrFromI4(lNum,0,0,Temp)
  $CED
  LenCad=CadLong(Temp)\2
  Res=RepCarac(32,LenCad)
  WideCharToMultiByte(0,0,Temp,-1,Res,LenCad,Nulo,Nulo)
  Resultado=Res
FinProc


Proc CadReal(Referencia lpStr:Cadena):Real
  Var Temp:Cadena, LenCad:Entero, Num:Real
  LenCad=CadLong(lpStr)
  Temp=RepCarac(0,(LenCad+1)*2)
  MultiByteToWideChar(0,0,lpStr,LenCad,Temp,LenCad*2)
  Si (VarR8FromStr(Temp,0,0,Num)) GenerarError errTipoIncompatible
  Resultado=Num
FinProc


Proc RealCad(lNum:Real):Cadena
  Var Temp,Res:Cadena, LenCad:Entero
  $CED-
  VarBstrFromR8(lNum,0,0,Temp)
  $CED
  LenCad=CadLong(Temp)\2
  Res=RepCarac(32,LenCad)
  WideCharToMultiByte(0,0,Temp,-1,Res,LenCad,Nulo,Nulo)
  Resultado=Res
FinProc


Proc ParteCad(Referencia Texto:Cadena, Comienzo:EnteroSig, Opcional Longit:EnteroSig=-1):Cadena
  Var Temp:Cadena, LenTxt:EnteroSig
  Si (Comienzo<1) Or (Longit<(-1)) GenerarError errParamInv
  LenTxt=CadLong(Texto)
  Si (LenTxt=0) GenerarError errParamInv
  Si (Longit=-1) Longit=LenTxt-Comienzo+1
  Si (Comienzo+Longit-1>LenTxt) Or (Comienzo>LenTxt) GenerarError errParamInv
  Temp=RepCarac(0,Longit)
  CopyMemory(CadPtr(Temp),CadPtr(Texto)+Comienzo-1,Longit)
  Resultado=Temp
FinProc


Proc ParteEnt(Referencia Texto:Entero, Comienzo:EnteroSig, Opcional Longit:EnteroSig=-1):Entero
Var TXT:Cadena
TXT = EntCad(Texto)
Devolver CadEnt(ParteCad(TXT,Comienzo,Longit))
FinProc


Proc IzquierdaCad(Referencia Texto:Cadena,Longit:EnteroSig):Cadena
  Si (CadLong(Texto)<=Longit) Devolver Texto
  Resultado=ParteCad(Texto,1,Longit)
FinProc


Proc IzquierdaEnt(Referencia Texto:Entero,Longit:EnteroSig):Entero
Var TXT:Cadena
TXT = EntCad(Texto)
Devolver CadEnt(IzquierdaCad(TXT,Longit))
FinProc


Proc DerechaCad(Referencia Texto:Cadena,Longit:EnteroSig):Cadena
  Var LenTxt:Entero
  LenTxt=CadLong(Texto)
  Si (LenTxt<=Longit) Devolver Texto
  Resultado=ParteCad(Texto,LenTxt-Longit+1,Longit)
FinProc


Proc DerechaEnt(Referencia Texto:Entero,Longit:EnteroSig):Entero
Var TXT:Cadena
TXT = EntCad(Texto)
Devolver CadEnt(DerechaCad(TXT,Longit))
FinProc


Proc CadenaDeMatrizByte(Referencia ByteAry[]:Byte):Cadena
  Var Temp:Cadena, LenTxt:EnteroSig
  LenTxt=LongMat(ByteAry)
  Si LenTxt<1 Salir
  Temp=RepCarac(0,LenTxt)
  CopyMemory(CadPtr(Temp),ByteAry@,LenTxt)
  Resultado=Temp
FinProc


Proc CadenaDePtrCad(Referencia PtrCad:Entero):Cadena
  Var Temp:Cadena, LenTxt:EnteroSig
  LenTxt=lstrlenptr(PtrCad)
  Si LenTxt<1 Salir
  Temp=RepCarac(0,LenTxt)
  CopyMemory(CadPtr(Temp),PtrCad,LenTxt)
  Resultado=Temp
FinProc


Proc Ascii(Referencia lpStr:Cadena):Byte
  Var i:Entero,@Ret:Byte
  Si (CadLong(lpStr))
    Ret@=CadPtr(lpStr)
    Resultado=Ret
  FinSi
FinProc


Proc BuscarEnCad(Referencia lpStr,lpMatch:Cadena,Opcional dwPos:Entero):Entero
  Var i,LongMatch,TotLng:Entero
  LongMatch=CadLong(lpMatch)
  Si (LongMatch=0) GenerarError errParamInv
  TotLng=CadLong(lpStr)-LongMatch+1
  Si (dwPos>TotLng) GenerarError errParamInv
  Si (dwPos=0) dwPos=1
  Contar i = dwPos a TotLng
    Si (ParteCad(lpStr,i,LongMatch)=lpMatch) Devolver i
  Seguir
FinProc


Proc BuscarEnEnt(Referencia lpStr,lpMatch:Entero,Opcional dwPos:Entero):Entero
Var TXT_A,TXT_B:Cadena
TXT_A = EntCad(lpStr)
TXT_B = EntCad(lpMatch)
Devolver BuscarEnCad(TXT_A,TXT_B,dwPos)
FinProc


Proc BuscarEnCadInv(Referencia lpStr,lpMatch:Cadena,Opcional dwPos:Entero):Entero
  Var i,LongMatch,TotLng:Entero
  LongMatch=CadLong(lpMatch)
  Si (LongMatch=0) GenerarError errParamInv
  TotLng=CadLong(lpStr)-LongMatch+1
  Si (dwPos>TotLng) GenerarError errParamInv
  Si (dwPos=0) dwPos=TotLng
  Contar i = dwPos a 1 Dec
    Si (ParteCad(lpStr,i,LongMatch)=lpMatch) Devolver i
  Seguir
FinProc


Proc BuscarEnEntInv(Referencia lpStr,lpMatch:Entero,Opcional dwPos:Entero):Entero
Var TXT_A,TXT_B:Cadena
TXT_A = EntCad(lpStr)
TXT_B = EntCad(lpMatch)
Devolver BuscarEnCadInv(TXT_A,TXT_B,dwPos)
FinProc


Proc TruncarCadena(Referencia lpStr:Cadena):Cadena 
  Var Pos:Entero,lpStrA,A:Cadena
  lpStrA = lpStr
  A = Null
  Pos=BuscarEnCad(lpStrA,A)
  Si (Pos=0) Devolver lpStr
  Si (Pos=1) Salir
  Resultado=IzquierdaCad(lpStr,Pos-1)
FinProc


Proc Reemplazar(Referencia Str,Match,Rep:Cadena, Opcional Pos:EnteroSig):Cadena
  Var i,LongMatch,CL,TotLng:Entero
  LongMatch=CadLong(Match)
  Si (LongMatch=0) GenerarError errParamInv
  CL=CadLong(Str)
  Si (CL=0) Salir
  TotLng=CL-LongMatch+1
  Si (Pos>TotLng) GenerarError errParamInv
  Si (Pos=0) Pos=1
  Contar i = 1 a CL
    Si ((i>=Pos) And (i<=TotLng) And (ParteCad(Str,i,LongMatch)=Match))
      Resultado=Resultado+Rep
      i=i+LongMatch-1
    SiNo
      Resultado=Resultado+ParteCad(Str,i,1)
    FinSi
  Seguir
FinProc


Proc Separar(Referencia Texto,Sep:Cadena, Opcional PosInicio:Entero=1, Opcional MaxRet:Entero):Cadena[]
  Var Pos,Ret,Mx,SepLen,TxtLen:Entero
  SepLen = CadLong(Sep)
  Si (SepLen = 0) GenerarError errParamInv
  TxtLen = CadLong(Texto)
  Borrar Resultado
  Repetir
    Ret = BuscarEnCad(Texto,Sep,Pos+1)
    Si (Ret=0) Salir Repetir
    Redim Preservar Resultado, Mx + 1
    Resultado[Mx] = ParteCad(Texto,Pos+1,Ret-Pos-1)
    Pos = Ret + SepLen - 1
    Mx = Mx + 1
    Si (MaxRet) Si (Mx = MaxRet) Salir Repetir
    Si (Pos>=TxtLen) Salir Repetir
  PorSiempre
  Redim Preservar Resultado, Mx + 1
  Resultado[Mx] = > (Pos>=TxtLen) ? ("") : (ParteCad(Texto,Pos+1))
FinProc



Clase pscCadenas, _
  Buff[]:PSCCADENASINFO, _
  MaxBuff,iHwnd:Entero
Público:
  ClaseVar Eventos:PSCCADENAS_EVENTINFO
Privado:
  Proc evCambiar()
    Si (Eventos.AlCambiar@) Eventos.AlCambiar(hWnd,0)
  FinProc
  Proc evAdd(Pos:EnteroSig)
    Si (Eventos.AlAgregar@) Eventos.AlAgregar(hWnd,Pos)
  FinProc
  Proc evDel(Pos:EnteroSig)
    Si (Eventos.AlQuitar@) Eventos.AlQuitar(hWnd,Pos)
  FinProc
  Proc EsValido(Indice:Entero)
    Si (Indice>=MaxBuff) GenerarError errParamInv
  FinProc
  Proc GetItem(Indice:Entero):Cadena
    EsValido(Indice)
    Resultado=Buff[Indice].Texto
  FinProc
  Proc SetItem(Valor:Cadena, Indice:Entero)
    EsValido(Indice)
    Buff[Indice].Texto=Valor
    evCambiar()
  FinProc
  Proc GetDato(Indice:Entero):EnteroSig
    EsValido(Indice)
    Resultado=Buff[Indice].Dato
  FinProc
  Proc SetDato(Valor:EnteroSig, Indice:Entero)
    EsValido(Indice)
    Buff[Indice].Dato=Valor
  FinProc
  Proc GetCantidad:Entero
    Resultado=MaxBuff
  FinProc
Público:
  Prop hWnd:Entero
    Lec:iHwnd
    Esc:iHwnd
  FinProp
  Prop Cantidad:Entero
    Lec:GetCantidad
  FinProp
  Prop Item:Cadena
    Lec:GetItem
    Esc:SetItem
  FinProp
  Prop Dato:EnteroSig
    Lec:GetDato
    Esc:SetDato
  FinProp
  Proc Agregar(Texto:Cadena)
    MaxBuff=MaxBuff+1
    Redim Preservar Buff,MaxBuff
    Buff[MaxBuff-1].Texto=Texto
    evAdd(MaxBuff-1)
  FinProc
  Proc Insertar(Texto:Cadena, Indice:Entero)
    Var i:Entero
    EsValido(Indice)
    Agregar("")
    Contar i=Indice+1 a MaxBuff
      Buff[i]=Buff[i-1]
    Seguir
    Buff[Indice].Texto=Texto
    evAdd(Indice)
  FinProc
  Proc Eliminar(Indice:Entero)
    Var i:Entero
    EsValido(Indice)
    MaxBuff=MaxBuff-1
    Contar i=Indice+1 a MaxBuff
      Buff[i-1]=Buff[i]
    Seguir
    Redim Preservar Buff,MaxBuff
    evDel(Indice)
  FinProc
FinClase
